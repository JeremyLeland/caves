<link rel="stylesheet" href="styles.css">
<body>
  <!-- TODO: Group entities like this? Might also let us format them easier -->
  <!-- <div id="tileMap"></div>
  <div id="props"></div>
  <div id="actors"></div>-->
</body>

<script type="module">
  import { GUI } from '../lib/dat.gui.module.js';

  import * as TileMap from './tilemap.js';
  import * as Prop    from './prop.js';
  import * as Actor   from './actor.js';

  import * as Pathfinding from './pathfinding.js';

  const level = {
    "ground": {
      "cols": 10, "rows": 10,
      "tileInfoKeys": [ "dirt", "grass", "snow", "empty" ],
      "tileMap": [
        0, 0, 0, 0, 0, 3, 1, 1, 1, 1,
        0, 1, 1, 1, 0, 3, 0, 0, 0, 1,
        0, 1, 0, 1, 0, 3, 2, 2, 0, 1,
        3, 1, 1, 1, 0, 1, 0, 0, 0, 1,
        3, 0, 0, 0, 0, 1, 1, 1, 1, 3,
        3, 3, 3, 3, 0, 0, 3, 3, 3, 3,
        3, 0, 1, 0, 0, 0, 1, 0, 0, 3,
        0, 1, 0, 1, 0, 3, 1, 1, 0, 0,
        0, 0, 0, 0, 0, 3, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 3, 0, 0, 0, 0,
      ]
    },
    "props": [
      { "propInfoKey": "bush",  "col": 1, "row": 1 },
      { "propInfoKey": "bush",  "col": 2, "row": 2 },
      { "propInfoKey": "bush", "col": 8, "row": 4 },
      { "propInfoKey": "bush", "col": 5, "row": 6 },
    ],
    "actors": [
      { "actorInfoKey": "goblin",   "col": 2, "row": 1 },
      // { "actorInfoKey": "spider",   "col": 2, "row": 6 },
      // { "actorInfoKey": "hero",     "col": 3, "row": 7 },
      // { "actorInfoKey": "skeleton", "col": 4, "row": 8 },
    ]
  }

  // TODO: Make these init(), and have them prepare the DOM as well as CSS
  TileMap.prepareCSS();
  Prop.prepareCSS();
  Actor.prepareCSS();

  TileMap.fromJson( level.ground );
  const passableMap = TileMap.getPassableMap( level.ground, level.props );

  level.props.forEach( json => {
    Prop.fromJson( json );
    passableMap[ json.col + json.row * level.ground.cols ] = json.passable;
  } );

  const nodeMap = Pathfinding.getNodeMap( { 
    passableMap: passableMap,
    cols: level.ground.cols, rows: level.ground.rows,
    size: TileMap.TileSize
  } );
  const nodeList = nodeMap.filter( e => e != null );

  document.body.appendChild( Pathfinding.getNodeMapSVG( nodeMap ) );

  const actors = level.actors.map( json => Actor.fromJson( json ) );

  const settings = {
    showNodeMap: true,
    showNodePaths: true,
  };
  const gui = new GUI();
  gui.add( settings, 'showNodeMap' ).onChange( val => { 
    const nodeMapSVG = document.querySelector( '.nodeMap' );
    nodeMapSVG.style.display = val ? 'initial' : 'none'
  } );
  gui.add( settings, 'showNodePaths' ).onChange( val => {
    document.querySelectorAll( '.nodePath' ).forEach( 
      e => e.style.display = val ? 'initial' : 'none'
    );
  });

  function update( dt ) {
    actors.forEach( actor => {
      // actor.angle = Math.atan2( mouseY - actor.y, mouseX - actor.x );

      // TODO: Set path, or idle between goals
      if ( actor.path == null ) {
        actor.path = Pathfinding.getPath( getNodeAt( actor.x, actor.y ), getRandomNode() );

        if ( actor.pathSVG ) {
          document.body.removeChild( actor.pathSVG );
        }

        actor.pathSVG = Pathfinding.getPathSVG( actor.path );
        document.body.appendChild( actor.pathSVG );
      }

      Actor.update( {
        actor: actor,
        others: actors.filter( other => other != actor ),
        dt: dt
      } );
    } );
  }

  function getNodeAt( x, y ) {
    const col = Math.floor( x / TileMap.TileSize );
    const row = Math.floor( y / TileMap.TileSize );
    return nodeMap[ col + row * level.ground.cols ];
  }

  function getRandomNode() {
    return nodeList[ Math.floor( Math.random() * nodeList.length ) ];
  }

  let mouseX = 0, mouseY = 0;
  document.onmousemove = ( e ) => {
    mouseX = e.pageX;
    mouseY = e.pageY;
  };

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only
    update( now - lastTime );
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );


</script>