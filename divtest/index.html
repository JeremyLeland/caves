<link rel="stylesheet" href="styles.css">
<body>
  <!-- TODO: Group entities like this? Might also let us format them easier -->
  <!-- <div id="tileMap"></div>
  <div id="props"></div>
  <div id="actors"></div>-->
</body>

<script type="module">
  import { GUI } from '../lib/dat.gui.module.js';

  import * as TileMap from './tilemap.js';
  import * as Prop    from './prop.js';
  import * as Actor   from './actor.js';

  import * as Pathfinding from './pathfinding.js';

  const level = {
    "ground": {
      "cols": 10, "rows": 10,
      "tileInfoKeys": [ "dirt", "grass", "snow", "empty" ],
      "tileMap": [
        0, 0, 0, 0, 0, 2, 1, 1, 1, 1,
        0, 1, 1, 1, 0, 2, 0, 0, 0, 1,
        0, 1, 0, 1, 0, 2, 2, 2, 0, 1,
        2, 1, 1, 1, 0, 1, 0, 0, 0, 1,
        2, 0, 0, 0, 0, 1, 1, 1, 1, 2,
        2, 2, 2, 2, 0, 0, 2, 2, 2, 2,
        2, 0, 1, 0, 0, 0, 1, 0, 0, 2,
        0, 1, 0, 1, 0, 2, 1, 1, 0, 0,
        0, 0, 0, 0, 0, 2, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
      ]
    },
    "props": [
      { "propInfoKey": "bush",  "col": 1, "row": 1 },
      { "propInfoKey": "bush",  "col": 2, "row": 2 },
      { "propInfoKey": "bush", "col": 8, "row": 4 },
      { "propInfoKey": "bush", "col": 5, "row": 6 },
    ],
    "actors": [
      { "actorInfoKey": "goblin",   "team": "enemy",  "col": 2, "row": 1 },
      { "actorInfoKey": "spider",   "team": "enemy",  "col": 2, "row": 6 },
      { "actorInfoKey": "hero",     "team": "player", "col": 3, "row": 7 },
      { "actorInfoKey": "skeleton", "team": "enemy",  "col": 4, "row": 8 },
    ]
  }

  // TODO: Make these init(), and have them prepare the DOM as well as CSS
  TileMap.prepareCSS();
  Prop.prepareCSS();
  Actor.prepareCSS();

  TileMap.fromJson( level.ground );
  const passableMap = TileMap.getPassableMap( level.ground, level.props );

  level.props.forEach( json => {
    Prop.fromJson( json );
    passableMap[ json.col + json.row * level.ground.cols ] = json.passable;
  } );

  const nodeMap = Pathfinding.getNodeMap( { 
    passableMap: passableMap,
    cols: level.ground.cols, rows: level.ground.rows,
    size: TileMap.TileSize
  } );
  const nodeList = nodeMap.filter( e => e != null );

  document.body.appendChild( Pathfinding.getNodeMapSVG( nodeMap ) );

  const actors = level.actors.map( json => Actor.fromJson( json ) );
  const teams = [];

  actors.forEach( actor => { 
    actor.currentNode = getNodeAt( actor.x, actor.y )
    if ( !teams[ actor.team ] ) {
      teams[ actor.team ] = [];
    }
    teams[ actor.team ].push( actor );
  } );

  const settings = {
    showNodeMap: true,
    showNodePaths: true,
  };
  const gui = new GUI();
  gui.add( settings, 'showNodeMap' ).onChange( val => { 
    const nodeMapSVG = document.querySelector( '.nodeMap' );
    nodeMapSVG.style.display = val ? 'initial' : 'none'
  } );
  gui.add( settings, 'showNodePaths' ).onChange( val => {
    document.querySelectorAll( '.nodePath' ).forEach( 
      e => e.style.display = val ? 'initial' : 'none'
    );
  });

  function update( dt ) {
    // actor.angle = Math.atan2( mouseY - actor.y, mouseX - actor.x );
    teams[ 'enemy' ].forEach( enemy => {
      enemy.target ??= teams[ 'player' ][0];

      if ( enemy.target ) {
        enemy.path = Pathfinding.getPath( enemy.currentNode, enemy.target.currentNode );
        Actor.updatePathSVG( enemy );
      }
      else if ( enemy.path == null ) {
        enemy.path = Pathfinding.getPath( enemy.currentNode, getRandomNode() );
        Actor.updatePathSVG( enemy );
      }

      Actor.update( { actor: enemy, others: teams[ 'enemy' ], dt: dt } );
    });

    teams[ 'player' ].forEach( player => {
      if ( player.path == null ) {
        player.path = Pathfinding.getPath( player.currentNode, getRandomNode() );
        Actor.updatePathSVG( player );
      }

      Actor.update( { actor: player, others: teams[ 'player' ], dt: dt } );
    });
  }

  function getNodeAt( x, y ) {
    const col = Math.floor( x / TileMap.TileSize );
    const row = Math.floor( y / TileMap.TileSize );
    return nodeMap[ col + row * level.ground.cols ];
  }

  function getRandomNode() {
    return nodeList[ Math.floor( Math.random() * nodeList.length ) ];
  }

  let mouseX = 0, mouseY = 0;
  document.onmousemove = ( e ) => {
    mouseX = e.pageX;
    mouseY = e.pageY;
  };

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only
    update( now - lastTime );
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );


</script>