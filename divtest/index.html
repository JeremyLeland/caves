<link rel="stylesheet" href="styles.css">
<body>
  <!-- TODO: Group entities like this? Might also let us format them easier -->
  <!-- <div id="tileMap"></div>
  <div id="props"></div>
  <div id="actors"></div>-->
  <svg id="nodeMap"></svg>
  <svg id="nodePath"></svg>
</body>

<script type="module">
  import * as TileMap from './tilemap.js';
  import * as Prop    from './prop.js';
  import * as Actor   from './actor.js';

  import * as Pathfinding from './pathfinding.js';

  const level = {
    "ground": {
      "cols": 10, "rows": 10,
      "tileInfoKeys": [ "dirt", "grass", "snow" ],
      "tileMap": [
        0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        0, 1, 1, 1, 0, 1, 0, 0, 0, 1,
        0, 1, 0, 1, 0, 1, 2, 2, 0, 1,
        0, 1, 1, 1, 0, 1, 0, 0, 0, 1,
        0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        0, 1, 0, 1, 0, 0, 0, 0, 0, 0,
        0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
        0, 1, 0, 1, 0, 1, 1, 1, 0, 0,
        0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      ]
    },
    "props": [
      { "propInfoKey": "bush",  "col": 1, "row": 1 },
      { "propInfoKey": "bush",  "col": 2, "row": 2 },
      { "propInfoKey": "tree1", "col": 8, "row": 4 },
      { "propInfoKey": "tree1", "col": 5, "row": 6 },
    ],
    "actors": [
      { "actorInfoKey": "goblin",   "col": 1, "row": 5 },
      { "actorInfoKey": "spider",   "col": 2, "row": 6 },
      { "actorInfoKey": "hero",     "col": 3, "row": 7 },
      { "actorInfoKey": "skeleton", "col": 4, "row": 8 },
    ]
  }

  // TODO: Make these init(), and have them prepare the DOM as well as CSS
  TileMap.prepareCSS();
  Prop.prepareCSS();
  Actor.prepareCSS();

  TileMap.fromJson( level.ground );
  const passableMap = TileMap.getPassableMap( level.ground, level.props );

  level.props.forEach( json => {
    Prop.fromJson( json );
    passableMap[ json.col + json.row * level.ground.cols ] = json.passable;
  } );

  const nodeMap = Pathfinding.getNodeMap( { 
    passableMap: passableMap,
    cols: level.ground.cols, rows: level.ground.rows,
    size: TileMap.TileSize
  } );
  const nodeList = nodeMap.filter( e => e != null );

  const SVG_URI = 'http://www.w3.org/2000/svg';
  const nodeMapSVG = document.getElementById( 'nodeMap' );
  nodeMapSVG.setAttribute( 'width', level.ground.cols * TileMap.TileSize );
  nodeMapSVG.setAttribute( 'height', level.ground.rows * TileMap.TileSize );
  nodeMapSVG.appendChild( Pathfinding.getNodeMapSVG( nodeMap ) );

  const actors = level.actors.map( json => Actor.fromJson( json ) );

  const nodePathSVG = document.getElementById( 'nodePath' );
  nodePathSVG.setAttribute( 'width', level.ground.cols * TileMap.TileSize );
  nodePathSVG.setAttribute( 'height', level.ground.rows * TileMap.TileSize );
  actors.forEach( actor => {
    const start = getNodeAt( actor.x, actor.y );
    const end = getRandomNode();
    const path = Pathfinding.getPath( start, end );

    actor.path = path;

    nodePathSVG.appendChild( Pathfinding.getPathSVG( path ) );
  });

  function update( dt ) {
    actors.forEach( actor => {
      // actor.angle = Math.atan2( mouseY - actor.y, mouseX - actor.x );

      // TODO: Set path, or idle between goals
      actor.path ??= Pathfinding.getPath( getNodeAt( actor.x, actor.y ), getRandomNode() );

      Actor.update( {
        actor: actor,
        others: actors.filter( other => other != actor ),
        dt: dt
      } );
    } );
  }

  function getNodeAt( x, y ) {
    const col = Math.floor( x / TileMap.TileSize );
    const row = Math.floor( y / TileMap.TileSize );
    return nodeMap[ col + row * level.ground.cols ];
  }

  function getRandomNode() {
    return nodeList[ Math.floor( Math.random() * nodeList.length ) ];
  }

  let mouseX = 0, mouseY = 0;
  document.onmousemove = ( e ) => {
    mouseX = e.pageX;
    mouseY = e.pageY;
  };

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only
    update( now - lastTime );
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );


</script>