<link rel="stylesheet" href="../styles.css">
<script type="module">
  const tileMap = [
    [ 1, 1, 1, 1, 1 ],
    [ 1, 3, 3, 3, 1 ],
    [ 1, 3, 2, 3, 1 ],
    [ 1, 3, 2, 3, 1 ],
    [ 1, 3, 2, 3, 1 ],
    [ 3, 3, 2, 3, 1 ],
    [ 3, 2, 2, 3, 1 ],
    [ 3, 3, 3, 3, 1 ],
    [ 1, 1, 1, 1, 1 ],
  ];

  
  const TILE_WIDTH = 64, TILE_HEIGHT = 32;

  const cols = tileMap.length, rows = tileMap[0].length;

  const canvas = document.createElement('canvas');
  canvas.width = (rows + cols) * TILE_WIDTH / 2;
  canvas.height = (rows + cols) * TILE_HEIGHT / 2;
  document.body.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  const tileSheet = new Image();
  tileSheet.src = '../images/isometric/grassland_tiles.png';
  await tileSheet.decode();

  const TileInfo = {
    Grass: { 
      tiles: Array.from(Array(16), (_,i) => ({ col: i, row: 0 }))
    },
    Water: {
      depth: 1,
      tiles: Array.from(Array(16), (_,i) => ({ col: i, row: 19 }))
    },
    Edge:  {
      rows: 2,
      dirs: [
        { nw: true, ne: true, tiles: [ { col: 0, row: 15 }, { col: 4, row: 15 } ] },
        { ne: true, se: true, tiles: [ { col: 1, row: 15 }, { col: 5, row: 15 } ] },
        { sw: true, se: true, tiles: [ { col: 2, row: 15 }, { col: 6, row: 15 } ] },
        { nw: true, sw: true, tiles: [ { col: 3, row: 15 }, { col: 7, row: 15 } ] },
        { nw: true, ne: true, se: true, tiles: [ { col:  8, row: 15 }, { col: 12, row: 15} ] },
        { ne: true, sw: true, se: true, tiles: [ { col:  9, row: 15 }, { col: 13, row: 15 } ] },
        { nw: true, sw: true, se: true, tiles: [ { col: 10, row: 15 }, { col: 14, row: 15 } ] },
        { nw: true, ne: true, sw: true, tiles: [ { col: 11, row: 15 }, { col: 15, row: 15 } ] },
        { ne: true, tiles: [ { col: 0, row: 17 }, { col: 4, row: 17 } ] },
        { se: true, tiles: [ { col: 1, row: 17 }, { col: 5, row: 17 } ] },
        { sw: true, tiles: [ { col: 2, row: 17 }, { col: 6, row: 17 } ] },
        { nw: true, tiles: [ { col: 3, row: 17 }, { col: 7, row: 17 } ] },
      ]
    }
  };

  const tilesKey = [
    null, 
    TileInfo.Grass,
    TileInfo.Water,
    TileInfo.Edge
  ];

  const maxColRow = Math.max(cols, rows) - Math.max(0, rows - cols) - 1;

  for (let row = 0; row < rows; row ++) {
    for (let col = cols - 1; col >= 0; col --) {
      const tileIndex = tileMap[col][row];
      let tileInfo = tilesKey[tileIndex];

      if (tileInfo) {
        const w = (tileInfo.cols ?? 1) * TILE_WIDTH;
        const h = (tileInfo.rows ?? 1) * TILE_HEIGHT;
        const yOffset = (tileInfo.depth ?? 0) * TILE_HEIGHT;

        if (tileInfo.dirs) {
          const nw = tilesKey[tileMap[col-1][row-1]] == TileInfo.Grass;
          const ne = tilesKey[tileMap[col+1][row-1]] == TileInfo.Grass;
          const sw = tilesKey[tileMap[col-1][row+1]] == TileInfo.Grass;
          const se = tilesKey[tileMap[col+1][row+1]] == TileInfo.Grass;

          tileInfo = tileInfo.dirs.find(e =>
            (e.nw ?? false) == nw &&
            (e.ne ?? false) == ne &&
            (e.sw ?? false) == sw &&
            (e.se ?? false) == se
          ) ?? tileInfo.dirs[0];
        }

        tileInfo = tileInfo.tiles[Math.floor(Math.random() * tileInfo.tiles.length)];

        const sx = tileInfo.col * TILE_WIDTH;
        const sy = tileInfo.row * TILE_HEIGHT;
        
        const dx = (row + col) * TILE_WIDTH / 2;
        const dy = yOffset + (maxColRow - col + row) * TILE_HEIGHT / 2;
        
        ctx.drawImage(tileSheet, sx, sy, w, h, dx, dy, w, h);
      }
    }
  }
  
  function drawIsoTile(ctx, col, row, cols, rows, color) {
    const x = (row + col) * TILE_WIDTH / 2;
    const y = (rows - col + row - 1) * TILE_HEIGHT / 2;
    
    ctx.beginPath();
    ctx.moveTo(x                 , y + TILE_HEIGHT / 2);
    ctx.lineTo(x + TILE_WIDTH / 2, y                  );
    ctx.lineTo(x + TILE_WIDTH    , y + TILE_HEIGHT / 2);
    ctx.lineTo(x + TILE_WIDTH / 2, y + TILE_HEIGHT    );
    ctx.closePath();

    ctx.fillStyle = color;
    ctx.strokeStyle = 'gray';
    ctx.fill();
    ctx.stroke();
  }

</script>