<link rel="stylesheet" href="../styles.css">
<script type="module">

  const TILE_SIZE = 64;

  const heightMap = [
    [0, 0, 0, 0, 0],
    [0, 0, 1, 1, 0],
    [0, 1, 1, 1, 1],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
  ];
  const maxHeight = 1;

  const cols = heightMap.length - 1, rows = heightMap[0].length - 1;

  const canvas = document.createElement('canvas');
  canvas.width = (rows + cols) * TILE_SIZE / 2;
  canvas.height = maxHeight * TILE_SIZE + (rows + cols) * TILE_SIZE / 4;
  document.body.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  const sheet = new Image();
  sheet.src = '../images/isometric/iso-64x64-outside.png';
  await sheet.decode();

  const Tile = {
    Grass: 0
  }

  const TileCoords = {
    [Tile.Grass]: getCoordsArray([
      { 
        nw: 0, ne: 0, sw: 0, se: 0, 
        tiles: Array.from(Array(7), (_, i) => [i, 0]).concat(
          Array.from(Array(8), (_, i) => [i, 1]).concat(
            Array.from(Array(4), (_, i) => [i, 2])
          )
        )
      },
      { nw: 0, ne: 1, sw: 0, se: 0, tiles: [[0, 3]] },
      { nw: 0, ne: 1, sw: 0, se: 1, tiles: [[1, 3]] },
      { nw: 1, ne: 1, sw: 0, se: 0, tiles: [[2, 3]] },
      { nw: 0, ne: 0, sw: 0, se: 1, tiles: [[3, 3]] },
      { nw: 1, ne: 1, sw: 1, se: 1, tiles: [[4, 3]] },
      { nw: 1, ne: 0, sw: 0, se: 0, tiles: [[5, 3]] },
      { nw: 0, ne: 0, sw: 1, se: 1, tiles: [[6, 3]] },
      { nw: 1, ne: 0, sw: 1, se: 0, tiles: [[7, 3]] },
      { nw: 0, ne: 0, sw: 1, se: 0, tiles: [[8, 3]] },
      { nw: 1, ne: 0, sw: 1, se: 1, tiles: [[0, 4]] },
      { nw: 1, ne: 1, sw: 1, se: 0, tiles: [[1, 4]] },
      { nw: 1, ne: 1, sw: 0, se: 1, tiles: [[2, 4]] },
      { nw: 0, ne: 1, sw: 1, se: 1, tiles: [[3, 4]] },
    ])
  }

  function getCoordsArray(template) {
    return Array.from(Array(2), (_, nw) => 
      Array.from(Array(2), (_, ne) => 
        Array.from(Array(2), (_, sw) => 
          Array.from(Array(2), (_, se) =>
            template.find(tile =>
              (tile.nw ?? 0) == nw &&
              (tile.ne ?? 0) == ne &&
              (tile.sw ?? 0) == sw &&
              (tile.se ?? 0) == se
            )?.tiles.map(coord => [
              coord[0] * TILE_SIZE,
              coord[1] * TILE_SIZE
            ]) ?? []
          )
        )
      )
    );
  }


  const maxColRow = Math.max(cols, rows) - Math.max(0, rows - cols) - 1;

  ctx.beginPath();

  for (let row = 0; row < rows; row ++) {
    for (let col = cols - 1; col >= 0; col --) {
      const x = (row + col) * TILE_SIZE / 2;
      const y = (maxColRow - col + row) * TILE_SIZE / 4;

      ctx.moveTo(x                , y + TILE_SIZE / 4);
      ctx.lineTo(x + TILE_SIZE / 2, y                );
      ctx.lineTo(x + TILE_SIZE    , y + TILE_SIZE / 4);
      ctx.lineTo(x + TILE_SIZE / 2, y + TILE_SIZE / 2);
      ctx.lineTo(x                , y + TILE_SIZE / 4);

      const nw = heightMap[col][row];
      const ne = heightMap[col+1][row];
      const sw = heightMap[col][row+1];
      const se = heightMap[col+1][row+1];

      const coords = TileCoords[Tile.Grass];
      const tiles = coords[nw][ne][sw][se];

      const [sx, sy] = chooseRandom(tiles);
        
      const w = TILE_SIZE;
      const h = TILE_SIZE;  // * (TileHeight[layer] + 1);
      
      const yOffset = 0;  //-TILE_HEIGHT * TileHeight[layer];
        
      ctx.drawImage(sheet, sx, sy, w, h, x, y + yOffset, w, h);
    }
  }

  ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
  ctx.stroke();

  function chooseRandom(list) {
    return list[Math.floor(Math.random() * list.length)];
  }

</script>