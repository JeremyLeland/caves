<link rel="stylesheet" href="../styles.css">
<script type="module">
  import * as THREE from 'https://unpkg.com/three/build/three.module.js'

  const cols = 6, rows = 4;
  const tileMap = [
    0, 1, 2, 0, 1, 2,
    1, 2, 0, 1, 2, 0,
    2, 0, 1, 2, 0, 1,
    0, 1, 2, 0, 1, 2,
  ];
  
  const scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x222255 );

  const positions = [];
  const uvs = [];
  const indices = [];
  
  let index = 0;
  for ( let row = 0; row < rows; row ++ ) {
    for ( let col = 0; col < cols; col ++ ) {
      positions.push( col + 1, 0, row     );  uvs.push( 1, 1 );
      positions.push( col,     0, row     );  uvs.push( 0, 1 );
      positions.push( col + 1, 0, row + 1 );  uvs.push( 1, 0 );
      positions.push( col,     0, row + 1 );  uvs.push( 0, 0 );
      indices.push( index,     index + 1, index + 2 );
      indices.push( index + 2, index + 1, index + 3 );
      index += 4;
    }
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute( positions, 3 ));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute( uvs, 2 ));
  geometry.setIndex(indices);

  // const BLEND_TILE_SIZE = 1.0 / 8;

  // // NOTE: These are based on U,V coords, which start 0,0 at the bottom left
  // const BlendOffset = getCoordsArray([
  //   { sw: 1, se: 1, tiles: lineFrom( 0, 7 ) },
  //   { nw: 1, sw: 1, tiles: lineFrom( 0, 6 ) },
  //   { ne: 1, se: 1, tiles: lineFrom( 0, 5 ) },
  //   { nw: 1, ne: 1, tiles: lineFrom( 0, 4 ) },
    
  //   { nw: 1, ne: 1, sw: 1, se: 0, tiles: [ [ 4, 7 ], [ 4, 5 ] ] },
  //   { nw: 1, ne: 1, sw: 0, se: 1, tiles: [ [ 5, 7 ], [ 5, 5 ] ] },
  //   { nw: 1, ne: 0, sw: 1, se: 1, tiles: [ [ 4, 6 ], [ 4, 4 ] ] },
  //   { nw: 0, ne: 1, sw: 1, se: 1, tiles: [ [ 5, 6 ], [ 5, 4 ] ] },
    
  //   { se: 1, tiles: [ [ 6, 7 ], [ 6, 5 ] ] },
  //   { sw: 1, tiles: [ [ 7, 7 ], [ 7, 5 ] ] },
  //   { ne: 1, tiles: [ [ 6, 6 ], [ 6, 4 ] ] },
  //   { nw: 1, tiles: [ [ 7, 6 ], [ 7, 4 ] ] },
    
  //   // TODO: This part of the texture needs to be redone in GIMP with 
  //   // some sort of adding (rather than copying over)
  //   { ne: 1, sw: 1, tiles: [ [ 0, 3 ], [ 1, 2 ], [ 0, 1 ], [ 1, 0 ] ] },
  //   { nw: 1, se: 1, tiles: [ [ 1, 3 ], [ 0, 2 ], [ 1, 1 ], [ 0, 0 ] ] },
    
  //   { nw: 1, ne: 1, sw: 1, se: 1, tiles: [ [ 2, 3 ] ] },
  //   { nw: 0, ne: 0, sw: 0, se: 0, tiles: [ [ 3, 3 ] ] }
  // ]);

  // function lineFrom(col, row) {
  //   return Array.from(Array(4), (_, i) => [ col + i, row ]);
  // }
  
  // function getCoordsArray(template) {  
  //   return Array.from(Array(2), (_, nw) => 
  //     Array.from(Array(2), (_, ne) => 
  //       Array.from(Array(2), (_, sw) => 
  //         Array.from(Array(2), (_, se) =>
  //           template.find(tile =>
  //             (tile.nw ?? 0) == nw &&
  //             (tile.ne ?? 0) == ne &&
  //             (tile.sw ?? 0) == sw &&
  //             (tile.se ?? 0) == se
  //           )?.tiles ?? []
  //         )
  //       )
  //     )
  //   );
  // }


  const blendIndices = [];

  for ( let row = 0; row < rows; row ++ ) {
    for ( let col = 0; col < cols; col ++ ) {
      // const wCol = Math.max(0, col), eCol = Math.min(col + 1, cols - 1);
      // const nRow = Math.max(0, row), sRow = Math.min(row + 1, rows - 1);

      // const nwTile = tileMap[ wCol + nRow * cols ];
      // const neTile = tileMap[ eCol + nRow * cols ];
      // const swTile = tileMap[ wCol + sRow * cols ];
      // const seTile = tileMap[ eCol + sRow * cols ];

      // TODO: Handle multiple tile types
      // const coordsArray = BlendOffset[nwTile][neTile][swTile][seTile];
      // const [ x, y ] = chooseRandom(coordsArray);

      const i = tileMap[ col + row * cols ];
      blendIndices.push( i, i, i, i );
    }
  }

  // function chooseRandom(array) {
  //   return array[Math.floor(Math.random() * array.length)];
  // }
  
  geometry.setAttribute( 'blendIndex', new THREE.Int32BufferAttribute( blendIndices, 1 ));

  // Make the material
  const BLEND_SIZE = 256, NUM_BLENDS = 3;

  const size = BLEND_SIZE * BLEND_SIZE;
  const data = new Uint8Array( 3 * size * NUM_BLENDS );

  for ( let i = 0; i < NUM_BLENDS; i ++ ) {
    const r = Math.floor( Math.random() * 255 );
    const g = Math.floor( Math.random() * 255 );
    const b = Math.floor( Math.random() * 255 );

    for ( let j = 0; j < size; j ++ ) {
      const stride = ( i * size + j ) * 3;

      data[ stride ] = r;
      data[ stride + 1 ] = g;
      data[ stride + 2 ] = b;
    }
  }

  const blendTextures = new THREE.DataTexture2DArray( data, BLEND_SIZE, BLEND_SIZE, NUM_BLENDS );
  blendTextures.format = THREE.RGBFormat;
  blendTextures.type = THREE.UnsignedByteType;

  const material = new THREE.ShaderMaterial({
    uniforms: {
      blends: { value: blendTextures },
    },
    vertexShader: `
      in int blendIndex;
      out vec2 v_uv;
      flat out int i_blendIndex;
      void main() {
        v_uv = uv ;
        i_blendIndex = blendIndex;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      precision highp float;
      precision highp int;
      precision highp sampler2DArray;

      uniform sampler2DArray blends;
      in vec2 v_uv;
      flat in int i_blendIndex;

      out vec4 outColor;

      void main() {
        
        //vec4 color = texture2D(u_tex1, v_uv);
        //vec4 color2 = texture2D(u_tex2, v_uv);
        vec4 alpha = texture( blends, vec3( v_uv, i_blendIndex ) );

        //gl_FragColor = vec4( mix( color.rgb, color2.rgb, alpha.g ), 1.0 );
        outColor = alpha;
        //gl_FragColor = vec4( v_uv.x, v_uv.y, 0.0, 1.0 );
      }
    `,
    glslVersion: THREE.GLSL3,   // not sure if we need this
  });

  // const loader = new THREE.TextureLoader();
  // const texture1 = loader.load('../textures/grass_overcast.png', function() { material.uniforms.u_tex1.value = texture1; render(); });
  // const texture2 = loader.load('../textures/dirt.png', function() { material.uniforms.u_tex2.value = texture2; render(); });
  // const texture3 = loader.load('../textures/blend.png', function() { material.uniforms.u_tex3.value = texture3; render(); });

  // OLD
  // const materials = ['grass_overcast', 'dirt', 'sand', 'water'].map(
  //   e => new THREE.MeshBasicMaterial({
  //     map: loader.load(`../textures/${e}.png`, render)
  //   })
  // );

  // materials[3].alphaMap = loader.load('../textures/blend.png', render);
  // materials[3].transparent = true;

  const blueMat = new THREE.MeshBasicMaterial({ color: 0x0000ff });

  const mesh = new THREE.Mesh( geometry, material );
  scene.add( mesh );

  const light = new THREE.DirectionalLight( 0xffffff );
  light.position.set( 0, 1.0, 0.5 );
  light.target.position.set( 0, 0, 0 );
  scene.add( light );

  const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  camera.position.set( cols / 2, 3, rows * 1.5);//cols * 1.0, rows * 1.0 );
  camera.lookAt( cols / 2, 0, rows );

  const renderer = new THREE.WebGLRenderer();
  renderer.setSize( window.innerWidth, window.innerHeight );
  document.body.appendChild( renderer.domElement );

  render();

  function render() {
    renderer.render( scene, camera );
    //requestAnimationFrame( render );
  }
  
  //     window.addEventListener('resize', () => this.resize(), false)

  //     this.renderer.setSize( window.innerWidth, window.innerHeight )
  //     this.camera.aspect = window.innerWidth / window.innerHeight
  //     this.camera.updateProjectionMatrix()
  

</script>