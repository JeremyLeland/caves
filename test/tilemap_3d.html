<link rel="stylesheet" href="../styles.css">
<script type="module">
  import * as THREE from 'https://unpkg.com/three/build/three.module.js'

  const tileMap = [
    [ 0, 1, 0 ],
    [ 0, 1, 0 ],
    [ 0, 0, 1 ],
  ];

  const cols = tileMap.length, rows = tileMap[0].length;

  
  const scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x222255 );

  const geometry = new THREE.PlaneBufferGeometry( cols, rows, cols, rows );
  geometry.rotateX( -Math.PI / 2 );

  const BLEND_TILE_SIZE = 1.0 / 8;
  const BlendOffset = getCoordsArray([
    { sw: 1, se: 1, tiles: lineFrom( 0, 0 ) },
    { nw: 1, sw: 1, tiles: lineFrom( 0, 1 ) },
    { ne: 1, se: 1, tiles: lineFrom( 0, 2 ) },
    { nw: 1, ne: 1, tiles: lineFrom( 0, 3 ) },
    
    { nw: 1, ne: 1, sw: 1, se: 0, tiles: [ [ 4, 0 ], [ 4, 2 ] ] },
    { nw: 1, ne: 1, sw: 0, se: 1, tiles: [ [ 5, 0 ], [ 5, 2 ] ] },
    { nw: 1, ne: 0, sw: 1, se: 1, tiles: [ [ 4, 1 ], [ 4, 3 ] ] },
    { nw: 0, ne: 1, sw: 1, se: 1, tiles: [ [ 5, 1 ], [ 5, 3 ] ] },
    
    { se: 1, tiles: [ [ 6, 0 ], [ 6, 2 ] ] },
    { sw: 1, tiles: [ [ 7, 0 ], [ 7, 2 ] ] },
    { ne: 1, tiles: [ [ 6, 1 ], [ 6, 3 ] ] },
    { nw: 1, tiles: [ [ 7, 1 ], [ 7, 3 ] ] },
    
    // TODO: This part of the texture needs to be redone in GIMP with 
    // some sort of adding (rather than copying over)
    { nw: 1, se: 1, tiles: [ [ 6, 0 ], [ 6, 2 ], [ 7, 1 ], [ 7, 3 ] ] },
    { ne: 1, sw: 1, tiles: [ [ 7, 0 ], [ 7, 2 ], [ 6, 1 ], [ 6, 3 ] ] },
    
    { nw: 1 , ne: 1, sw: 1, se: 1, tiles: [ [ 2, 4 ] ] },
    { nw: 0 , ne: 0, sw: 0, se: 0, tiles: [ [ 3, 4 ] ] }
  ]);

  function lineFrom(col, row) {
    Array.from(Array(4), (_, i) => [ col + i, row ]);
  }
  
  function getCoordsArray(template) {  
    return Array.from(Array(2), (_, nw) => 
      Array.from(Array(2), (_, ne) => 
        Array.from(Array(2), (_, sw) => 
          Array.from(Array(2), (_, se) =>
            template.find(tile =>
              (tile.nw ?? 0) == nw &&
              (tile.ne ?? 0) == ne &&
              (tile.sw ?? 0) == sw &&
              (tile.se ?? 0) == se
            )?.tiles?.map(coord => [
              coord[0] * BLEND_TILE_SIZE,
              coord[1] * BLEND_TILE_SIZE
            ]) ?? []
          )
        )
      )
    );
  }


  const blendOffsets = [];

  for ( let row = 0; row <= rows; row ++ ) {
    blendOffsets.push( 0.0, 0.0 );

    for ( let col = 0; col < cols; col ++ ) {
      if ( row == rows ) {
        blendOffsets.push( 0.0, 0.0 );
      }
      else {
        const wCol = Math.max(0, col), eCol = Math.min(col + 1, cols - 1);
        const nRow = Math.max(0, row), sRow = Math.min(row + 1, rows - 1);

        const nwTile = tileMap[wCol][nRow];
        const neTile = tileMap[eCol][nRow];
        const swTile = tileMap[wCol][sRow];
        const seTile = tileMap[eCol][sRow];


        blendOffsets.push( tileMap[col][row] * 0.5 * BLEND_TILE_SIZE, tileMap[col][row] * 0.5 * BLEND_TILE_SIZE );
      }
    }
  }
  
  geometry.setAttribute( 'blendOffset', 
    new THREE.Float32BufferAttribute( blendOffsets, 2 ).setUsage( THREE.DynamicDrawUsage ) );

  // Make the material
  const material = new THREE.ShaderMaterial({
    uniforms: {
      u_tex1: {value: null},
      u_tex2: {value: null},
      u_tex3: {value: null},
      //u_tex4: {value: null},
    },
    vertexShader: `
      in vec2 blendOffset;
      out vec2 v_uv;
      flat out vec2 v_blendOffset;
      void main() {
        v_uv = uv ;
        v_blendOffset = blendOffset;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      in vec2 v_uv;
      flat in vec2 v_blendOffset;
      uniform sampler2D u_tex1;
      uniform sampler2D u_tex2;
      uniform sampler2D u_tex3;
      //uniform sampler2D u_tex4;
      void main() {
        // repeat UV for each tile
        vec2 mapSize = vec2( ${cols}.0, ${rows}.0 );
        vec2 uv = mod(v_uv * mapSize, 1.0);

        vec4 color = texture2D(u_tex1, uv);
        vec4 color2 = texture2D(u_tex2, uv);
        vec4 alpha = texture2D(u_tex3, v_blendOffset + uv * 0.125);

        //gl_FragColor = vec4( mix( color.rgb, color2.rgb, alpha.g ), 1.0 );
        gl_FragColor = alpha;
        //gl_FragColor = vec4( uv.x, uv.y, 0.0, 1.0 );
      }
    `,
  });

  const loader = new THREE.TextureLoader();
  const texture1 = loader.load('../textures/grass_overcast.png', function() { material.uniforms.u_tex1.value = texture1; render(); });
  const texture2 = loader.load('../textures/dirt.png', function() { material.uniforms.u_tex2.value = texture2; render(); });
  const texture3 = loader.load('../textures/blend.png', function() { material.uniforms.u_tex3.value = texture3; render(); });

  // const materials = ['grass_overcast', 'dirt', 'sand', 'water'].map(
  //   e => new THREE.MeshBasicMaterial({
  //     map: loader.load(`../textures/${e}.png`, render)
  //   })
  // );

  // materials[3].alphaMap = loader.load('../textures/blend.png', render);
  // materials[3].transparent = true;

  const mesh = new THREE.Mesh( geometry, material );
  scene.add( mesh );

  const light = new THREE.DirectionalLight( 0xffffff );
  light.position.set( 0, 1.0, 0.5 );
  light.target.position.set( 0, 0, 0 );
  scene.add( light );

  const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  camera.position.set( 0, cols * 1.0, rows * 1.0);
  camera.lookAt( 0, 0, 0 );

  const renderer = new THREE.WebGLRenderer();
  renderer.setSize( window.innerWidth, window.innerHeight );
  document.body.appendChild( renderer.domElement );

  function render() {
    renderer.render( scene, camera );
    //requestAnimationFrame( render );
  }
  
  //     window.addEventListener('resize', () => this.resize(), false)

  //     this.renderer.setSize( window.innerWidth, window.innerHeight )
  //     this.camera.aspect = window.innerWidth / window.innerHeight
  //     this.camera.updateProjectionMatrix()
  

</script>