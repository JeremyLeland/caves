<link rel="stylesheet" href="../styles.css">
<div id="ui" style="position: absolute; right: 0; text-align: right"></div>
<script type="module">
  import * as THREE from 'https://unpkg.com/three/build/three.module.js';
  import Stats from 'https://unpkg.com/three/examples/jsm/libs/stats.module.js';
  
  import * as Shaders from '../lib/Shaders.js';

  const scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x222255 );

  const geometry = new THREE.BoxBufferGeometry();
  
  const materials = {
    Perlin: new THREE.ShaderMaterial({
      vertexShader: Shaders.ObjectPositionOut,
      fragmentShader: `
        ${ Shaders.Noise3D }

        in vec3 v_pos;
        out vec4 outColor;

        void main() {
          float val = snoise( v_pos * 20.0 );
          outColor = vec4( val, val, val, 1.0 );
        }
      `,
      glslVersion: THREE.GLSL3,
    }),
    Clouds: new THREE.ShaderMaterial({
      vertexShader: Shaders.ObjectPositionOut,
      fragmentShader: `
        ${ Shaders.OctaveNoise }

        in vec3 v_pos;
        out vec4 outColor;

        void main() {
          float val = ( 1.0 + octaveNoise( v_pos ) ) / 2.0;
          outColor = vec4(val, val, val, 1.0);
        }
      `,
      glslVersion: THREE.GLSL3,
    }),
    Marble: new THREE.ShaderMaterial({
      uniforms: {
        scale: { value: 100.0 }
      },
      vertexShader: Shaders.ObjectPositionOut,
      fragmentShader: `
        ${ Shaders.OctaveNoise }
        uniform float scale;
        in vec3 v_pos;
        out vec4 outColor;

        void main() {
          float val = ( 1.0 + sin( octaveNoise( v_pos ) * scale ) ) / 2.0;
          outColor = vec4(val, val, val, 1.0);
        }
      `,
      glslVersion: THREE.GLSL3,
    }),
    Worley: new THREE.ShaderMaterial({
      uniforms: {
        points: { 
          value: [
            [ 0.83, 0.75 ],
            [ 0.60, 0.07 ],
            [ 0.28, 0.64 ],
            [ 0.31, 0.26 ],
          ].map( e => new THREE.Vector2( ...e ) )
        },
        u_time: { value: 0 }
      },
      vertexShader: Shaders.UVOut,
      // See: https://thebookofshaders.com/12/
      fragmentShader: `
        uniform vec2 points[4];
        uniform float u_time;

        in vec2 v_uv;
        out vec4 outColor;

        vec2 random2( vec2 p ) {
          return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
        }

        void main() {
          vec3 color = vec3(.0);

          // Scale
          vec2 st = v_uv * 3.0;

          // Tile the space
          vec2 i_st = floor(st);
          vec2 f_st = fract(st);

          float m_dist = 1.;  // minimum distance

          for (int y= -1; y <= 1; y++) {
              for (int x= -1; x <= 1; x++) {
                  // Neighbor place in the grid
                  vec2 neighbor = vec2(float(x),float(y));

                  // Random position from current + neighbor place in the grid
                  vec2 point = random2(i_st + neighbor);

                  // Animate the point
                  point = 0.5 + 0.5*sin(u_time + 6.2831*point);

                  // Vector between the pixel and the point
                  vec2 diff = neighbor + point - f_st;

                  // Distance to the point
                  float dist = length(diff);

                  // Keep the closer distance
                  m_dist = min(m_dist, dist);
              }
          }

          // Draw the min distance (distance field)
          color += m_dist;

          // Draw cell center
          color += 1.-step(.02, m_dist);

          // Draw grid
          color.r += step(.98, f_st.x) + step(.98, f_st.y);

          // Show isolines
          // color -= step(.7,abs(sin(27.0*m_dist)))*.5;

          outColor = vec4( color, 1.0 );
        }
      `,
      glslVersion: THREE.GLSL3,
    }),
    Grass: new THREE.ShaderMaterial({
      vertexShader: Shaders.UVOut,
      fragmentShader: `
        in vec2 v_uv;
        out vec4 outColor;

        float random (vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        vec2 random2( vec2 p ) {
          return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
        }

        void main() {

          float val = 0.0;

          const float width = 0.8;

          // Scale
          const float scale = 10.0;
          vec2 st = v_uv * scale;

          // Tile the space
          vec2 i_st = floor(st);
          vec2 f_st = fract(st);

          for (int y= -1; y <= 1; y++) {
            for (int x= -1; x <= 1; x++) {
              // Neighbor place in the grid
              vec2 neighbor = vec2(float(x),float(y));

              for ( int i = 0; i < 10; i ++ ) {
                vec2 r = i_st + neighbor + float( i ) * vec2( 1423.14, 155.11 );

                float a = random( r ) * -10.0 - 5.0;
                vec2 vertex = ( i_st + neighbor + random2( r ) ) / scale;
                
                float xh = v_uv.x - vertex.x;
                float xh2 = xh * xh;
                float upper = a * xh2 + vertex.y;
                float lower = ( a - width ) * xh2 + vertex.y; 
                
                float dir = step( 0.5, random( r ) ) * 0.2 - 0.1;
                float left  = vertex.x + min( 0.0, dir );
                float right = vertex.x + max( 0.0, dir );

                if ( left < v_uv.x && v_uv.x < right && lower < v_uv.y && v_uv.y < upper ) {
                  val = abs( ( v_uv.x - vertex.x ) / dir );
                }
              }
            }
          }

          //outColor = vec4( a, vertex, 1.0 );
          outColor = vec4( val, val, val, 1.0 );
        }
      `,
      glslVersion: THREE.GLSL3,
    }),
    Turf: new THREE.ShaderMaterial({
      uniforms: {
        layers: {
          value: [
            // Grass
            {
              color: new THREE.Vector4( 0.3, 1.0, 0.0, 1.0 ),
              scale: 50.0,
              octaves: 3,
            },
            // Dirt
            {
              color: new THREE.Vector4( 1.0, 0.5, 0.0, 1.0 ),
              scale: 13.0,
              octaves: 4,
            },
            // Blend
            {
              color: new THREE.Vector4( 1.0, 1.0, 1.0, 1.0 ),
              scale: 5.0,
              octaves: 4,
            },
          ]
        }
      },
      vertexShader: Shaders.ObjectPositionOut,
      fragmentShader: `
        ${ Shaders.OctaveNoise }
        struct Layer {
          vec4 color;
          float scale;
          int octaves;
        };

        uniform Layer layers[3];

        // Grass = 3, 50.0
        // Dirt = 4, 13.0

        in vec3 v_pos;
        out vec4 outColor;

        void main() {
          float grass = ( 1.0 + octaveNoise( v_pos * layers[ 0 ].scale, layers[ 0 ].octaves, 0.5 ) ) / 2.0;
          float dirt = 1.5 * abs( octaveNoise( v_pos * layers[ 1 ].scale, layers[ 1 ].octaves, 0.5 ) );
          float blend = ( 1.0 + octaveNoise( v_pos * layers[ 2 ].scale, layers[ 2 ].octaves, 0.5 ) ) / 2.0;

          
          outColor = mix( grass * layers[ 0 ].color, dirt * layers[ 1 ].color, blend );
        }
      `,
      glslVersion: THREE.GLSL3,
    }),
    // Grass: Green clouds with simplex-controlled direction lighter lines?
    // Wood floor: streaky tan noise with rectangles?
  };

  const mesh = new THREE.Mesh( geometry, materials.Turf );
  scene.add( mesh );

  const light = new THREE.DirectionalLight( 0xffffff );
  light.position.set( 0, 1.0, 0.5 );
  light.target.position.set( 0, 0, 0 );
  scene.add( light );

  const camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 1000 );
  camera.position.set( 0, 0, 2 );
  camera.lookAt( 0, 0, 0 );

  const renderer = new THREE.WebGLRenderer();
  document.body.appendChild( renderer.domElement );

  const stats = new Stats();
  document.body.appendChild( stats.dom );

  window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );
    requestAnimationFrame( animate );
  }
  window.onresize();

  const ui = document.getElementById( 'ui' );
  for (let mat in materials) {
    const button = document.createElement( 'button' );
    button.innerText = mat;
    button.oninput = () => mesh.material = materials[ mat ];
    ui.appendChild( button );
  }

  const controls = document.createElement( 'div' );

  materials.Turf.uniforms.layers.value.forEach( layer => {
    for ( let prop in layer ) {
      const property = layer[ prop ];

      const label = document.createTextNode( prop );
      const val = document.createTextNode( property );
      const br = document.createElement( 'br' );
      
      const slider = document.createElement( 'input' );
      slider.type = 'range';
      slider.value = property;
      slider.min = Math.ceil( property / 10 );
      slider.max = property * 2;
      slider.oninput = () => {
        layer[ prop ] = slider.value;
        val.textContent = slider.value;
      }
      
      [ label, slider, val, br ].forEach( e => controls.appendChild( e ) );
    }
  });

  
  
  ui.appendChild( controls );

  function animate( time ) {
    requestAnimationFrame( animate );

    materials.Worley.uniforms.u_time.value = time / 1000;

    mesh.rotation.set( Math.PI / 4, Math.PI / 4, 0 );

    // mesh.rotation.x += 0.001;
    // mesh.rotation.y += 0.001;

    renderer.render( scene, camera );
    stats.update();
  }

</script>