<link rel="stylesheet" href="../styles.css">
<div id="ui" style="position: absolute; right: 0"></div>
<script type="module">
  import * as THREE from 'https://unpkg.com/three/build/three.module.js';
  import Stats from 'https://unpkg.com/three/examples/jsm/libs/stats.module.js';
  
  import * as Shaders from '../lib/Shaders.js';

  const scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x222255 );

  const geometry = new THREE.BoxBufferGeometry();
  
  const materials = {
    Perlin: new THREE.ShaderMaterial({
      vertexShader: Shaders.ObjectPositionOut,
      fragmentShader: `
        ${ Shaders.SimplexNoise }

        in vec3 v_pos;
        out vec4 outColor;

        void main() {
          float val = simplexNoise3( v_pos * 20.0 );
          outColor = vec4( val, val, val, 1.0 );
        }
      `,
      glslVersion: THREE.GLSL3,
    }),
    Clouds: new THREE.ShaderMaterial({
      vertexShader: Shaders.ObjectPositionOut,
      fragmentShader: `
        ${ Shaders.FractalNoise }

        in vec3 v_pos;
        out vec4 outColor;

        void main() {
          float val = ( 1.0 + fractalNoise( v_pos ) ) / 2.0;
          outColor = vec4(val, val, val, 1.0);
        }
      `,
      glslVersion: THREE.GLSL3,
    }),
    Marble: new THREE.ShaderMaterial({
      vertexShader: Shaders.ObjectPositionOut,
      fragmentShader: `
        ${ Shaders.FractalNoise }

        in vec3 v_pos;
        out vec4 outColor;

        void main() {
          float val = ( 1.0 + sin( fractalNoise( v_pos ) * 100.0 ) ) / 2.0;
          outColor = vec4(val, val, val, 1.0);
        }
      `,
      glslVersion: THREE.GLSL3,
    }),
    Worley: new THREE.ShaderMaterial({
      vertexShader: Shaders.UVOut,
      // See: https://thebookofshaders.com/12/
      fragmentShader: `
        in vec2 v_uv;
        out vec4 outColor;

        void main() {
          vec3 color = vec3(.0);

          // Cell positions
          vec2 point[4];
          point[0] = vec2(0.83,0.75);
          point[1] = vec2(0.60,0.07);
          point[2] = vec2(0.28,0.64);
          point[3] = vec2(0.31,0.26);

          float m_dist = 1.;  // minimum distance

          // Iterate through the points positions
          for (int i = 0; i < 4; i++) {
              float dist = distance(v_uv, point[i]);

              // Keep the closer distance
              m_dist = min(m_dist, dist);
          }

          // Draw the min distance (distance field)
          color += m_dist;

          // Show isolines
          // color -= step(.7,abs(sin(50.0*m_dist)))*.3;

          outColor = vec4( color, 1.0 );
        }
      `,
      glslVersion: THREE.GLSL3,
    }),
  };

  const mesh = new THREE.Mesh( geometry, materials.Marble );
  scene.add( mesh );

  const light = new THREE.DirectionalLight( 0xffffff );
  light.position.set( 0, 1.0, 0.5 );
  light.target.position.set( 0, 0, 0 );
  scene.add( light );

  const camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 1000 );
  camera.position.set( 0, 0, 2 );
  camera.lookAt( 0, 0, 0 );

  const renderer = new THREE.WebGLRenderer();
  document.body.appendChild( renderer.domElement );

  const stats = new Stats();
  document.body.appendChild( stats.dom );

  window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );
  }
  window.onresize();

  const ui = document.getElementById( 'ui' );
  for (let mat in materials) {
    const button = document.createElement( 'button' );
    button.innerText = mat;
    button.onclick = () => mesh.material = materials[mat];
    ui.appendChild( button );
  }
  
  animate();

  function animate() {
    requestAnimationFrame( animate );

    mesh.rotation.x += 0.005;
    mesh.rotation.y += 0.005;

    renderer.render( scene, camera );
    stats.update();
  }

</script>