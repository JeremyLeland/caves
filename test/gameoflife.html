<!DOCTYPE HTML>
<html>
  <head>
    <title>Game of Life Generation</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <link rel="stylesheet" href="../styles.css">
  </head>
  <body>
    <canvas id="canvas" width="1000px" height="700px" style="float: left"></canvas>
    
    <script type="module">
      import { TileMap } from '../src/TileMap.js';
      
      const SIZE = 16;
      const LIFE_CHANCE = 0.4, BIRTH_LIMIT = 4, DEATH_LIMIT = 2;
      let cells = Array(40).fill().map(x => Array(40).fill(false));

      for (var row = 0; row < cells[0].length; row ++) {
        for (var col = 0; col < cells.length; col ++) {
          cells[col][row] = Math.random() < LIFE_CHANCE;
        }
      }

      for (let i = 0; i < 6; i ++) {
        cells = doLife(cells);
      }
      
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (var row = 0; row < cells[0].length; row ++) {
        for (var col = 0; col < cells.length; col ++) {
          ctx.fillStyle = cells[col][row] ? 'black' : 'brown';
          ctx.fillRect(col * SIZE, row * SIZE, SIZE, SIZE);
        }
      }

      // See https://gamedevelopment.tutsplus.com/tutorials/generate-random-cave-levels-using-cellular-automata--gamedev-9664
      function doLife(oldCells) {
        const COLS = oldCells.length, ROWS = oldCells[0].length;
        const newCells = Array(COLS).fill().map(x => Array(ROWS).fill(false));
        
        for (let row = 0; row < ROWS; row ++) {
          for (let col = 0; col < COLS; col ++) {

            // Count nearby walls (out of bounds is also walls)
            let nearby = 8;
            for (let r = Math.max(0, row - 1); r <= Math.min(ROWS - 1, row + 1); r ++) {
              for (let c = Math.max(0, col - 1); c <= Math.min(COLS - 1, col + 1); c ++) {
                if (r == row && c == col) {
                  // skip
                }
                else if (oldCells[c][r] == false) {
                  nearby --;
                }
              }
            }

            // Apply rules for birthing and dying
            newCells[col][row] = nearby > (oldCells[col][row] ? DEATH_LIMIT : BIRTH_LIMIT);
          }
        }

        return newCells;
      }

    </script>
  </body>
</html>
